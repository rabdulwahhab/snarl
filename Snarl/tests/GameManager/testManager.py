import sys
import json
from Util import intifyTuple, whichBoardInLevel, isTileOnBoard
from Convert import convertJsonDungeon
from Types import *
import GameManager
from Rulechecker import playerCanMoveTo, destHasKey, destHasExit, destHasEnemy

"""
PLANNING SESSION:
Flow:
0. [X] parse json
1. [X] Take in data, convert it to dungeon
2. [ ] Init a manager-trace (MT)
3. [ ] Output an initial player vision to each player (Loop), add those updates to MT
4. [ ] Loop on turns Executing Moves (The given number of turns was performed)
    EXIT immediately if:
        - One of the move input streams is exhausted
        - The level is over

    a. we do the MOVE
        if need to execute another move (invalid)
            bb. `continue` if invalid
        else
            b. append the status (could be generated by acc on dungeon)
    c. append the updates
5. [ ] When done, output complete status (may be able to use functions from testState)

Function wishlist:
- given list of names, and list of points -> actor-position-list
- getPlayerVision()
- given a turn, outputs [ (name), (actor-move), (result) ]
- given a status, outputs [ (name), (player-update) ]


"Generally, I like test harnesses"
    - Saleha
"""


def anyOutOfMoves(jsonActorMoveListList: list):
    for moveList in jsonActorMoveListList:
        if len(moveList) == 0:
            return True
    return False


def isCurrentLevelOver(game: Dungeon):
    currLevel: Level = game.levels[game.currLevel]
    currBoard: Board = currLevel.boards[currLevel.currBoard]
    return currLevel.exitUnlocked and len(currBoard.players) == 0


def getPlayerUpdate(playerName: str, game: Dungeon):
    """
    PlayerUpdateType is:
    {
      "type": "player-update",
      "layout": (tile-layout), # getLayout?
      "position": (point), # getPlayer.location
      "objects": (object-list), # getLocationsAround.map(if destHasItem || desthasKey -> return object)
        [ { "type": "key", "position": [ 4, 2 ] },
               { "type": "exit", "position": [ 7, 17 ] } ]
      "actors": (actor-position-list) # potentially getLocationsAround.map(if destHasEnemy -> return enemy)
    }
    """
    output = {"type": "player-update"}
    output["layout"] = getLayout()
    output["position"] = getPlayer(game.levels[game.currLevel], playerName)
    output["objects"] = getPlayer()



def getPlayersUpdates(game, managerTrace):
    # FIXME implement
    for name in jsonNameList:
        # send initial player updates to all players in game
        update = getPlayerUpdate(name, game)
        managerTrace.append(update)
    return []


def getPlayer(level: Level, playerName: str):
    for board in level.boards:
        if playerName in board.players.keys():
            return board.players[playerName]
    return None


def getMoveStatus(currLevel: Level, playerName: str, move: dict):
    dest = intifyTuple(move["to"])
    if destHasKey(dest, currLevel):
        return [playerName, move, "Key"]
    elif destHasExit(dest, currLevel):
        return [playerName, move, "Exit"]
    elif destHasEnemy(dest, currLevel.boards[whichBoardInLevel(currLevel, dest)]):
        return [playerName, move, "Eject"]
    else:
        return [playerName, move, "OK"]


def executeTurns(game: Dungeon, maxNumTurns: int, jsonActorMoveListList: list,
                 jsonNameList: list, jsonLevel: dict):
    # Send initial player updates to all players in game
    managerTrace = getPlayersUpdates(game, [])
    i = 0
    while i < maxNumTurns:
        # 0. Exit checking
        if anyOutOfMoves(jsonActorMoveListList) or isCurrentLevelOver(game):
            break
        # 1. Run all moves in turn
        for j in range(len(
                jsonActorMoveListList)):  # execute each move for a player in a turn
            playerMoveList = jsonActorMoveListList[i]
            validMove = False
            while not validMove and len(playerMoveList) > 0:
                # do first move in playerMoveList, if valid, set flag
                move = playerMoveList[0]
                playerName = jsonNameList[j]
                currLevel: Level = game.levels[game.currLevel]
                player = getPlayer(currLevel, playerName) # pot bug??
                # apply
                if not move["to"]:  # skipped turn
                    validMove = True
                    managerTrace += [[playerName, move, "OK"]] # pot bug adding??
                    managerTrace = getPlayersUpdates(game, managerTrace)
                elif playerCanMoveTo(move["to"], player, currLevel, 2):
                    GameManager.move(playerName, move["to"], game) # pot bug not mutating??
                    managerTrace += getMoveStatus(currLevel, playerName, move) # pot bug wrong return types??
                    managerTrace = getPlayersUpdates(game, managerTrace)
                    validMove = True
                else:
                    managerTrace += [[playerName, move, "Invalid"]]
                    validMove = False

                del playerMoveList[0]

        i += 1
    return managerTrace, game


def getPlayerEnemyJson(jsonPlayerList: list, jsonPointList: list):
    """
    Will output a tuple of actor-position-lists representing players and enemies
    """
    jsonPlayers = []
    jsonEnemies = []
    numPlayers = len(jsonPlayerList)
    for i in range(0, len(jsonPointList)):
        if i < numPlayers:
            # Create a player actor type and append to jsonPlayers
            newPlayer = {"type":     "player", "name": jsonPlayerList[i],
                         "position": jsonPointList[i]}
            jsonPlayers.append(newPlayer)
        else:
            # Create an enemy actor type and append to jsonPlayers
            enemyName = "creature" + str(i)
            newEnemy = {"type":     "zombie", "name": enemyName,
                        "position": jsonPointList[i]}
            jsonEnemies.append(newEnemy)
    return (jsonPlayers, jsonEnemies)


# INPUT: [name-list, level, natural, point-list, actor-move-list-list]

def main():
    try:
        # Read input
        inputJson = sys.stdin.read()

        # Parse json
        parsedJson = json.loads(inputJson.replace("\n", ""))
        jsonNameList, jsonLevel, maxNumTurns, jsonPointList, jsonActorMoveListList = parsedJson

        # For converJsonDungeon we need: jsonLevel, jsonPlayers, c jsonEnemies, amd unlockedExit boolean
        # We have json level, and set jsonExitLocked as False
        # TODO: we need to iterate through jsonNameList and jsonPointList to create json Players and jsonEnemies,
        jsonPlayers, jsonEnemies = getPlayerEnemyJson(jsonNameList,
                                                      jsonPointList)
        game = convertJsonDungeon(jsonLevel, jsonPlayers, jsonEnemies)

        # 1. cal a MAJOR function that does the looping, returns manager-Trace and a game
        managerTrace, finalGame = executeTurns(game, maxNumTurns,
                                               jsonActorMoveListList,
                                               jsonNameList, jsonLevel)

        # 2. Using the game returned in 1 + original json, get the state of the game
        outputState = getFinalState(finalGame, jsonLevel)

        # 3. Append both, and output, cheers.
        output = [outputState, managerTrace]

        print(json.dumps(output))
    except json.JSONDecodeError:
        print("Malformed input.")
        sys.exit(1)
    except KeyboardInterrupt:
        print("Exiting...")
        sys.exit(0)


if __name__ == '__main__':
    main()
